<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[手把手教你撸一个泡妞神奇]]></title>
      <url>http://localhost:4000/2017/01/11/romantic-words/</url>
      <content type="html"><![CDATA[<p>用 canvas 做的一个漫天星空，星星变成字，自己把自己感动的表白页面</p>
<p>其实东西是一年前写的，二话不说，先看<a href="http://honggc.b0.upaiyun.com/romantic-words/index.html" target="_blank" rel="external">效果</a>（点击屏幕可显示下一句）</p>
<p><img src="http://honggc.b0.upaiyun.com/blog/starsss.gif" alt="stars"></p>
<p>当时我是在 codepan 上看到一个很漂亮的 <a href="http://codepen.io/iamfrontender/details/yNVPeX" target="_blank" rel="external">pan</a>，漫天星空，男孩独自看着，当时我就想如果可以把星星变成字就好了，于是就写了字的那一部分，背景还是用原来的，写完就用来表白了哈哈哈哈，效果怎么样嘛~~~反正就是追到了，哇哈哈哈哈，接下来说说是怎么做的吧。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>相信好多人一看就知道应该是用 canvas 做的了，具体做法就是在 canvas 画很多很多的点，然后根据你要显示的字准确排列，最后实现最后的效果。</p>
<h4 id="画字"><a href="#画字" class="headerlink" title="画字"></a>画字</h4><p>首先我在画布上画了 1200 个点，用这些点来组成我们要显示的字，用不到的字就隐藏起来。在组成字之前我们需要知道每个点的具体的位置，这里的做法是首先在画布上用 ctx.fillText() 先画出我们要显示的字，然后用 ctx.getImageData() 得到画布上每个像素点的信息，在把这些像素点的信息转化为我们每个点的坐标，最后就能通过点来显示我们的字了，具体看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, CANVASWIDTH, CANVASHEIGHT)</div><div class="line">  ctx.fillStyle = <span class="string">'rgb(255, 255, 255)'</span></div><div class="line">  ctx.textBaseline = <span class="string">'middle'</span></div><div class="line">  ctx.font = textSize + <span class="string">'px \'Avenir\', \'Helvetica Neue\', \'Arial\', \'sans-serif\''</span></div><div class="line">  ctx.fillText(text, (CANVASWIDTH - ctx.measureText(text).width) * <span class="number">0.5</span>, CANVASHEIGHT * <span class="number">0.5</span>)</div><div class="line"></div><div class="line">  <span class="comment">// 得到画布矩形的像素数据</span></div><div class="line">  <span class="keyword">let</span> imgData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, CANVASWIDTH, CANVASHEIGHT)</div><div class="line">  particleText(imgData)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">particleText</span> (<span class="params">imgData</span>) </span>&#123;</div><div class="line">  <span class="comment">// 点坐标获取</span></div><div class="line">  <span class="keyword">var</span> pxls = []</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> w = CANVASWIDTH; w &gt; <span class="number">0</span>; w -= <span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> h = <span class="number">0</span>; h &lt; CANVASHEIGHT; h += <span class="number">3</span>) &#123;</div><div class="line">      <span class="keyword">var</span> index = (w + h * (CANVASWIDTH)) * <span class="number">4</span></div><div class="line">      <span class="keyword">if</span> (imgData.data[index] &gt; <span class="number">1</span>) &#123;</div><div class="line">        pxls.push([w, h])</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="点的运动"><a href="#点的运动" class="headerlink" title="点的运动"></a>点的运动</h4><p>点在初始化的时候会被随机分布到画布的各个位置，在点的坐标确定之后，就会让点慢慢移动到目的地，具体的做法是在每一帧中根据点的上一帧的位置和点的目的地位置计算得出在该帧中点的坐标，让点慢慢的移动到目的地。</p>
<h4 id="星星闪烁效果"><a href="#星星闪烁效果" class="headerlink" title="星星闪烁效果"></a>星星闪烁效果</h4><p>这个效果实现很简单，就是让星星不停的震动，具体就是让点的目的地坐标不停的进行小范围的偏移。具体请看代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每次通过加上 Math.random() * 15 对目的地做偏移/</span></div><div class="line">X = pxls[i - <span class="number">1</span>][<span class="number">0</span>] - p.px + <span class="built_in">Math</span>.random() * <span class="number">15</span></div><div class="line">Y = pxls[i - <span class="number">1</span>][<span class="number">1</span>] - p.py + <span class="built_in">Math</span>.random() * <span class="number">15</span></div></pre></td></tr></table></figure>
<p>代码都放到了 <a href="https://github.com/hongguancheng/romantic-words" target="_blank" rel="external">github</a> 上了，祝大家表白成功哈哈哈哈。</p>
<p>demo 演示：<a href="http://honggc.b0.upaiyun.com/romantic-words/index.html" target="_blank" rel="external">http://honggc.b0.upaiyun.com/romantic-words/index.html</a></p>
<p>github 地址：<a href="https://github.com/hongguancheng/romantic-words" target="_blank" rel="external">https://github.com/hongguancheng/romantic-words</a></p>
<p>背景地址：<a href="http://codepen.io/iamfrontender/details/yNVPeX" target="_blank" rel="external">http://codepen.io/iamfrontender/details/yNVPeX</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[再学一遍 this]]></title>
      <url>http://localhost:4000/2017/01/09/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8D%20this/</url>
      <content type="html"><![CDATA[<p>最近在看《你不知道的 Javascript》，看到了关于 this 的介绍，收获良多。这里分享一下书中关于 this 的介绍。</p>
<h3 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h3><p>在了解 this 的工作原理之前首先要理清我们对 this 的一些错误的认识。</p>
<h4 id="指向自身"><a href="#指向自身" class="headerlink" title="指向自身"></a>指向自身</h4><p>我们很容易会把 this 理解成为指向函数本身，这个从英语的语法上是说的通的。然而事实并不是这样，我们看看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo.a = <span class="number">1</span></div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<p>最后输出的结果是 undefined 并不是 1，原因是 this 并不指向函数对象而指向了global 对象（浏览器是 window）</p>
<h4 id="指向它的作用域"><a href="#指向它的作用域" class="headerlink" title="指向它的作用域"></a>指向它的作用域</h4><p>第二个常见的误解是，this 指向了函数的词法作用域。</p>
<p>this 在任何情况下都不会指向函数的词法作用域。词法作用域确实很像一个对象，但是作用域”对象”只存在于 JavaScript 引擎内部。</p>
<p>下面看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">1</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()</div></pre></td></tr></table></figure>
<p>最后的结果还是 undefined，原因跟上一个例子的原因一样。</p>
<h3 id="this-全面解析"><a href="#this-全面解析" class="headerlink" title="this 全面解析"></a>this 全面解析</h3><p>所以 this 究竟指向哪里呢？这取决于函数的调用位置（也就是函数的调用方法）。找到调用位置之后需要应用下面提到的四条规矩，然后再看看如果多条规则同时使用时他们的优先级。</p>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>首先要介绍的就是最常用的函数调用类型，可以把这个规则看作是无法应用其他规矩的默认规则。看下面例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span></div><div class="line"></div><div class="line">foo() <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>在调用 foo() 时，这里的 this 会指向全局对象，所以会输出 1。</p>
<p>如果是用的严格模式，那么 this 会绑定到 undefined。上面的例子会报错。</p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>接下来的规则是函数调用的位置是否有上下文对象，请看下面例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj.foo() <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>这里的函数调用位置会使用 obj 的上下文，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
<h5 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h5><p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定。</p>
<p>看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span> <span class="comment">// a是全局对象的属性 </span></div><div class="line">bar(); <span class="comment">// "oops, global"</span></div></pre></td></tr></table></figure>
<p>这里的 bar 实际上是引用 foo 函数本身，因此这里的 bar() 应是默认绑定。</p>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  <span class="comment">// fn其实引用的是foo</span></div><div class="line">  fn(); <span class="comment">// &lt;-- 调用位置!</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span>; <span class="comment">// a是全局对象的属性</span></div><div class="line">doFoo(obj.foo); <span class="comment">// "oops, global"</span></div></pre></td></tr></table></figure>
<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</p>
<p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = <span class="string">'oops, global'</span>; <span class="comment">// a是全局对象的属性 </span></div><div class="line">setTimeout(obj.foo, <span class="number">100</span>); <span class="comment">// "oops, global"</span></div></pre></td></tr></table></figure>
<p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123; </div><div class="line">  <span class="comment">// 等待 delay 毫秒</span></div><div class="line">  fn(); <span class="comment">// &lt;-- 调用位置!</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>当我们分析隐式绑定时，需要在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。那么如果我们不想这么做就可以在对象上强制调用函数呢？</p>
<p>一般是用 call(…) 和 apply(…)，他们的第一个参数是一个对象，它们会把这个对象绑定到 this。我们称之为显式绑定。</p>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line">foo.call(obj); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>这里通过 foo.call(…) 在 foo 调用时把 this 绑定到 obj 上。</p>
<p>如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对象，这个原始值会被转换成它的对象形式(也就是 new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。</p>
<p>可惜,显式绑定仍然无法解决我们之前提出的丢失绑定问题。</p>
<h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>但是显式绑定的一个变种可以解决这个问题。</p>
<p>思考下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  foo.call(obj)</div><div class="line">&#125;</div><div class="line">bar() <span class="comment">// 2</span></div><div class="line">setTimeout(bar, <span class="number">100</span>) <span class="comment">// 2</span></div><div class="line"><span class="comment">// 硬绑定的 bar 不可能再修改它的 this </span></div><div class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>这里我们创建了函数 bar，并在函数内手动调用了 foo.call(obj)，所以无论怎么调用 bar，它都会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定,因此我们称之为硬绑定。</p>
<p>硬绑定的典型应用场景就是创建一个包裹函数,传入所有的参数并返回接收到的所有值:            </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> foo.apply(obj, <span class="built_in">arguments</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>) <span class="comment">// 2 3 </span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>另一种使用方法是创建一个可以重复使用的辅助函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something</div><div class="line">&#125;</div><div class="line"><span class="comment">// 简单的辅助绑定函数 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn, obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = bind(foo, obj)</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>) <span class="comment">// 2 3 </span></div><div class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>由于硬绑定是一种非常常用的模式,所以在 ES5 中提供了内置的方法Function.prototype. bind,它的用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj)</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>) <span class="comment">// 2 3 </span></div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>这是最后一条规则。使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建(或者说构造)一个全新的对象。</li>
<li>这个新对象会被执行[[原型]]连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</li>
</ol>
<p>思考下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = a</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>现在我们已经了解了函数调用中 this 绑定的四条规则，你需要做的就是找到函数的调用位 置并判断应当应用哪条规则。但是,如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。</p>
<p>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。</p>
<p>隐式绑定和显式绑定哪个优先级更高？我们来测试一下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">3</span>,</div><div class="line">  <span class="attr">foo</span>: foo</div><div class="line">&#125;</div><div class="line">obj1.foo() <span class="comment">// 2</span></div><div class="line">obj2.foo() <span class="comment">// 3</span></div><div class="line">obj1.foo.call(obj2) <span class="comment">// 3</span></div><div class="line">obj2.foo.call(obj1); <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>可以看到，显式绑定优先级更高。</p>
<p>接下来比较 new 绑定和显式绑定谁的优先级更高。因为 new 和 call/apply 无法一起使用，所以我们用硬绑定来测试他们的优先级：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">something</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = something</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.bind(obj1)</div><div class="line">bar(<span class="number">2</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">// 2</span></div><div class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> bar(<span class="number">3</span>)</div><div class="line"><span class="built_in">console</span>.log(obj1.a) <span class="comment">// 2 </span></div><div class="line"><span class="built_in">console</span>.log(baz.a) <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>从上面例子我们可以看出，虽然 bar 被硬绑定到 obj1 上了，但是 new bar(3) 并没有把 obj1.a 修改为 3，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。所以说 new 绑定的优先级比显式绑定高。</p>
<h4 id="判断-this"><a href="#判断-this" class="headerlink" title="判断 this"></a>判断 this</h4><p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断:</p>
<ol>
<li><p>函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo()</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = foo.call(obj2)</div></pre></td></tr></table></figure>
</li>
<li><p>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = obj1.foo()</div></pre></td></tr></table></figure>
</li>
<li><p>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> bar = foo()</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="ES6-箭头函数"><a href="#ES6-箭头函数" class="headerlink" title="ES6 箭头函数"></a>ES6 箭头函数</h3><p>ES6 中介绍了一种无法使用上面介绍的规则的特殊函数：箭头函数。</p>
<p>箭头函数并不是使用 function 关键字定义的，而是使用被称为“胖箭头”的操作符 =&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。</p>
<p>我们来看看箭头函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回一个箭头函数 </span></div><div class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// this 继承自 foo()</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> bar = foo.call(obj1)</div><div class="line">bar.call(obj2); <span class="comment">// 2,不是3!</span></div></pre></td></tr></table></figure>
<p>foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。（new 也不行！）</p>
<p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(self.a)</div><div class="line">  &#125;, <span class="number">100</span>)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>: <span class="number">2</span></div><div class="line">&#125;</div><div class="line">foo.call(obj); <span class="comment">// 2</span></div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端工程-自动上传 CDN]]></title>
      <url>http://localhost:4000/2017/01/03/npm-scripts-cdn/</url>
      <content type="html"><![CDATA[<p>最近有个朋友跟我说到每次上线好麻烦，项目每次 build 完之后都需要打开 CDN 的工具来上传静态的文件，然后复制 CDN 的 URL 进行在相应的位置进行替换。我突然想起了我一年前也碰到类似的问题，当时我还没有操作 CDN 的权限还要别人帮忙上传，上一次线十分的麻烦。于是当时做了个自动化上传 CDN 的工具，大大减少了重复性的工作。</p>
<p>当时用的是 grunt，所以写的是 <a href="https://github.com/hongguancheng/grunt-enai-upyun" target="_blank" rel="external">grunt 的插件</a>，用法好简单，在 grunt build 完之后，执行 grunt enai_upyun 就可以把生成好的目录中的所有文件都上传到 CDN 上，好方便有木有。</p>
<p>后来我们改用 webpack 作为构建工具，所以我用了类似的方法写了一个 <a href="https://github.com/hongguancheng/npm-scripts-cdn" target="_blank" rel="external">npm script 版</a>的上传工具，用法也差不多，后来我结合了 make 组合了下构建命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">build:</div><div class="line">	npm run build</div><div class="line"></div><div class="line">upload-upyun: build </div><div class="line">	npm run enaiUpyun</div><div class="line">	</div><div class="line">release: </div><div class="line">	make upload-upyun</div></pre></td></tr></table></figure>
<p>只需要 make release 一句命令就好了。懒的不行哈哈哈哈哈。</p>
<p>虽然我写的都是基于 upyun 的，但比如其他的服务比如七牛什么的都有相应的 SDK，可以根据自己的需求扩展一下，我把代码都放到了 Github 上了：</p>
<ul>
<li><a href="https://github.com/hongguancheng/grunt-enai-upyun" target="_blank" rel="external">grunt-cdn-upyun</a></li>
<li><a href="https://github.com/hongguancheng/npm-scripts-cdn" target="_blank" rel="external">npm-scripts-cdn</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[年底啦！总结下吧]]></title>
      <url>http://localhost:4000/2016/12/30/2016-summary/</url>
      <content type="html"><![CDATA[<p>不知不觉一年就过去了，这是我来公司的第二年，比起上一年今年在前端这一块变化还是非常的大的，可以说整个前端变化都非常的大，我们公司的前端也跟上了整体的步伐。接下来是对今年的一些思考和展望。</p>
<h3 id="The-Good"><a href="#The-Good" class="headerlink" title="The Good"></a>The Good</h3><p>首先说说好的方面吧，去年我们前端是只有我一个人，今年前端团队终于多了两个人，在前端方面我也没有像之前那么随意了，更加注重团队的发展和怎么才能让我们前端小组开发的更爽，工作效率更高。</p>
<p>总的来说 2016 年主要的个人贡献就是完成了前端工程的基础构建。</p>
<h4 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h4><p>回想起去年我刚来的时候，前端什么都没有，还是用着比较传统的方式，移动端用的是 zepto，后台用的是 jquery + bootstrap。到年中的时候才在移动端用了些自动化的工具。当时还没有前端工程化的概念。自从去年年末接触到 react 的时候才开始觉得我们的前端需要有所改变，不再是单纯做一个切图仔。</p>
<h5 id="库-框架选型"><a href="#库-框架选型" class="headerlink" title="库/框架选型"></a>库/框架选型</h5><p>在 520 活动的时候我们就开始用了 vue.js 作为前端的主要框架作为移动端页面的主要框架，解放了不少生产力，通过前端组件化可以合理的对 UI 组件进行分治，大大加强了代码的复用率，也方便了日后的维护。</p>
<h5 id="简单构建优化和模块化开发"><a href="#简单构建优化和模块化开发" class="headerlink" title="简单构建优化和模块化开发"></a>简单构建优化和模块化开发</h5><p>在选用 vue.js 之前我是用 grunt 来做为构建工具，现在因为项目需要进行模块化开发，最后选用了 webpack 作为构建工具，模块化开发的最大价值应该是分治，因为 Webkit 宣布默认打开 ES6 module 功能，CommonJS、AMD、UMD以及所有模块加载器全部过时，我们选用了 ES6 module。</p>
<h5 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h5><p>还记得之前有个同事说过，如果你一件事情重复做了 3 遍就需要想办法去做优化，也就是 Don`t repeat your self。前端的自动化是通过 make 加上 npm script 组合的一连串命令执行预先写好的 node 代码完成自动化构建、上传静态文件、自动分环境等操作，上线只需一个命令加上去 apolo 点一下就行了。</p>
<p>同时用 Yeoman 编写了前端项目的脚手架，从此新项目开始就不用傻傻的去复制就项目的代码了，同时还可以再创建项目的时候加入一些配置，按照需求创建项目。</p>
<h5 id="积累"><a href="#积累" class="headerlink" title="积累"></a>积累</h5><p>我在项目中加入了一个各个项目公用的 git submodule。一年之中不断的写了许多公用的代码和工具的方法，包括了一些简单的弹窗和 Ajax 模块等，这个仓库以后一定还会慢慢的积累，方便日后的开发。对于不能放在公共仓库的代码就放在脚手架内。</p>
<h4 id="后台前端框架"><a href="#后台前端框架" class="headerlink" title="后台前端框架"></a>后台前端框架</h4><p>之前用的是 react + reflux，今天在 6.0 改版的时候决定重新写后台，借此机会我换了下结构，用的是 react + redux，虽然项目看起来好像复杂了不少，不过理解了之后一定是有利于项目的开发和日后的维护的。同时对之前简单的构建工具的配置进行了整理，开发起来会更加的方便。</p>
<h3 id="The-Bad"><a href="#The-Bad" class="headerlink" title="The Bad"></a>The Bad</h3><p>好的说完了说说做的不好的吧。</p>
<ul>
<li>首先是我的个人问题，工作的时候有时会有点小情绪，这个需要克制一下。</li>
<li>工作缺少自测，其实这点是必须做的，但是我常常会忽略或者是做的不够认真，以后开发如果条件允许就去借一些手机在身边一起开发</li>
<li>应该及时重构代码而不是“到时候”，提升代码质量。</li>
</ul>
<h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>今年前端团队终于小有规模，希望在来年我们能共同进步吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用 CSS3 做守望先锋的 loader]]></title>
      <url>http://localhost:4000/2016/11/15/overwatch-loader/</url>
      <content type="html"><![CDATA[<p>东西是前阵子写的现在拿出来说下，记得当时守望先锋刚出来没多久，因为电脑比较烂，加载地图速度一直好慢。。。等的时候就一直看着右下角的 loading 动画，看着看着就想着能不能用 CSS3 实现出来，后来为了研究这个动画进了好多好多次训练房间，最后弄出来还原度还是挺高的，效果如下：</p>
<iframe id="cp_embed_EyGjqy" src="//codepen.io/CCG/embed/EyGjqy?height=400&theme-id=0&slug-hash=EyGjqy&default-tab=result" scrolling="no" frameborder="no" height="400" allowtransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>
<p><br> </p>
<h3 id="中间-logo-部分的实现"><a href="#中间-logo-部分的实现" class="headerlink" title="中间 logo 部分的实现"></a>中间 logo 部分的实现</h3><p>中间的 logo 是由一个大圆环，两个平行四边形还有两个三角形组合而成的，平行四边形用 transform: skew 实现，三角形用 border 就可以了。</p>
<h3 id="圆环动画效果"><a href="#圆环动画效果" class="headerlink" title="圆环动画效果"></a>圆环动画效果</h3><p>先说说圆环的实现，圆环有几种实现的方法，第一种是直接用 border</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.overwatch</span> &#123;</div><div class="line">    <span class="attribute">border</span>: <span class="number">10px</span> solid transparent;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">10px</span> solid <span class="number">#B6B8C0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://honggc.b0.upaiyun.com/blog/%E5%9C%86%E7%8E%AF.jpg" alt="圆环"></p>
<p>这样就能实现一个 1/4 园环，但是动画中的圆环大小不一所以明显不适合。我这边巧用了 clip 实现。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ring</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">220px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">220px</span>;</div><div class="line">    <span class="attribute">border</span>: <span class="number">6px</span> solid <span class="built_in">rgba</span>(161, 164, 176, 0.5);</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">clip</span>: <span class="built_in">rect</span>(0px, 142px, 100px, 90px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://honggc.b0.upaiyun.com/blog/%E5%9C%86%E7%8E%AF2.jpg" alt="圆环"></p>
<p>这样就可以简单实现一些小的圆环了，但是用这种圆环来做动画效果非常的蛋疼，要动过 clip 的变化来使圆环大小变化，而且在圆环边缘位置的切线并不是垂直的，不够美观，所以我这里只用这种方法来实现一些小变化不大的圆环，而大的变化大的圆环我用了实现圆形进度条的方法来实现，具体 <a href="https://www.xiabingbao.com/css/2015/07/27/css3-animation-circle.html" target="_blank" rel="external">看这里</a>。</p>
<p>最后添加动画效果就可以实现最终效果了，出了这个我还用了类似的方法实现了<a href="http://codepen.io/CCG/pen/KrANmJ" target="_blank" rel="external">另一个守望先锋的 loading 动画</a>，还原度也是挺好的。</p>
]]></content>
    </entry>
    
  
  
</search>
